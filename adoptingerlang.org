#+TITLE:     Adopting Erlang
#+AUTHOR:    Tristan Sloughter
#+DRAWERS: HIDDEN HINT SOLUTION
#+EMAIL:     t@crashfast.com
#+DATE:      \today
#+DESCRIPTION: Adopting Erlang.
#+KEYWORDS: erlang

# \setcounter{secnumdepth}{-1}

#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS: [oneside,11pt]
#+ATTR_LATEX: :width 4in
#+OPTIONS: H:6
#+LATEX_HEADER: \usepackage[Bjornstrup]{fncychap}
#+LATEX_HEADER: \usepackage[svgnames]{xcolor}
#+LATEX_HEADER: \usepackage[tikz]{bclogo}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \newenvironment{alert}{\begin{bclogo}}{\end{bclogo}}
#+OPTIONS: ^:{}
#+HUGO_BASE_DIR: .
#+HUGO_SECTION: docs
#+HUGO_PAIRED_SHORTCODES: %alert

* Introduction
:PROPERTIES:
:EXPORT_FILE_NAME: introduction
:END:

TODO: explain what this book is for; do it last.

* Development
:PROPERTIES:
:EXPORT_FILE_NAME: development
:END:
#+latex_header: \usepackage[utf8]{inputenc}
#+latex_header: \usepackage{pmboxdraw} % for directory listings

The first section of this book is dedicated to getting a working installation working, and understanding the actual structure of a project. This section will also cover how to import dependencies in your project, how to build projects that contain multiple OTP applications, write tests for your projects, and also a few other interesting topics.

** Setup

In this chapter, you will go through the basic steps required to install Erlang/OTP on most major platforms. The instructions will aim for a basic set-up, and in some more popular platforms, will also target running multiple Erlang/OTP versions at once, as a team with growing projects is likely to have to test multiple deploy scenarios.

You will also see how to install Rebar3, the official build tool for the Erlang community, and base configurations for various text editors.

*** Installing Erlang/OTP

The first step is to get a proper install of Erlang/OTP in place. This is not going to be a uniform experience on all platforms, but we'll at least make sure everyone following these steps has a fully functioning setup for any work environment.

**** Choosing a Version

Erlang/OTP is released on a fairly stable and predictable schedule, with well-defined criteria for backwards-incompatible changes.

Erlang versions are numbered according to a =<Major>.<Minor>.<Patch>= scheme, as described in the [[http://erlang.org/doc/system_principles/versions.html#version_scheme][Erlang/OTP system principles]]. In some rare circumstances, other digits are bolted on as "branched" versions, which you likely won't have to care about.

Here are some example possible versions:

- 22.0-rc1
- 21.3
- 21.2.3
- 21.1
- 19.3
- 17.0
- R16B03 (this is a legacy version format that hasn't been used since 2014)

As you can see, the =Patch= version is not mentioned when no patch is required. The release schedule for Erlang goes a bit like this:

1. Once per year, around February or March, a release candidate for the next major version is announced (with a suffix such as =-rc1=, or =-rc2=). This release candidate is made available for users who want to build from source, in order to test that their applications and system will work well with it
2. A few months later (April to June), the major release is cut and made public. Major releases contain large new features that require bigger virtual machine changes, and are also allowed to introduce backwards-incompatible changes
3. At a frequency of every three or four months, a minor release is made public, which usually includes stability fixes and minor feature additions in individual libraries
4. If a critical bug has been found in some circumstances, either for security or stability reasons, a patch release may be announced.

#+attr_shortcode: info
#+attr_latex: :environment bclogo :options [logo=\bcinfo, couleurBarre=orange, noborder=true, couleur=white]{Information}
#+begin_alert
Backwards incompatible changes are usually going through a cycle of deprecation before being removed, which tends to leave ample time to adapt. The policy is described in the [[http://erlang.org/doc/system_principles/misc.html][Support, Compatibility, Deprecations, and Removal]] document published by the OTP team at Ericsson.
#+end_alert

In some rare scenarios, hard-and-fast deprecations do happen, and it may take a few weeks for the community to come up with workarounds.

A team that adopts Erlang will therefore likely want to adopt a maintenance schedule that fits the main releases if they want to avoid falling too far behind. While it is possible to only upgrade occasionally, you will find that it is often easier to do a bit of maintenance somewhat often than a lot of maintenance at once.

Do note that patch-level releases are often only announced on the [[http://erlang.org/mailman/listinfo/erlang-questions][mailing lists]] and tagged on [[https://github.com/erlang/otp][the main git repository on GitHub]], but are otherwise not packaged on the main website.

**** Windows

If you are a Windows user, it is recommended that you use Windows 10 for any Erlang development. Prior versions can work, but community tools such as Rebar3 are only tested on Windows 10, for example.

Building on Windows from source has been notoriously difficult, and it is therefore recommended that you stick to the pre-built copies distributed on [[https://www.erlang.org/downloads][www.erlang.org/downloads]], or alternatively those built by [[https://www.erlang-solutions.com/resources/download.html][Erlang Solutions Ltd.]].

The installer for these versions comes with a wizard that will take you through all the required steps.

Do not forget to add Erlang/OTP to your =PATH= variable to contain your Erlang/OTP installation, since this will let you call it from the command-line:


1. In the start menu, search for "system environment variables" and select the "Edit the System and Environment Variables (Control Panel)" option
2. At the bottom of the "System Properties" window that has just open, press the "Environment Variables..." button
3. Select the =Path= variable (or create it if it does not exist) and click the "Edit" button
4. Add an entry for Erlang/OTP that matches the installation path, usually something like =C:\Program Files\erl10.2\bin=. The entries put earlier in the list will be loaded first.
5. Save the options
6. Close and restart any terminal you were running.

If you do development in the long term, you will be able to install multiple versions that way. You can control which one is used by changing and modifying the =PATH= variable's priorities in paths.

If you are a purist when it comes to Windows development, you may be quite comfortable in an environment such as Visual Studio, where pretty much everything can be done from within the IDE. Erlang comes from a different environment, and a lot of the instructions we'll use in this book are focused on using the command line to build everything.

If you are looking for a terminal to run the command line on Windows, various options are available:

- Use PowerShell as a terminal. Most commands in this book should work fine with it, but some edge cases may exist.
- Download and install [[https://git-scm.com/download/win][git for Windows]], which will come with a =git-bash= shell that will work well with all tooling and most commands in this book
- Try [[https://www.fosshub.com/ConEmu.htm][ConEmu]] as a nicer terminal emulator to work with
- Use [[https://cmder.net/][Cmder]] which is a Windows console emulator that packages most of the above options rather well
- Use [[https://www.cygwin.com][Cygwin]] at your own risk; you will need to rebuild your software from source to work well with it, and tools like Rebar3 dynamically figure out they're on Windows, which historically has caused a few path problems when interacting with Cygwin

You can then use the editor or IDE of your choosing to work with Erlang components.

**** OSX

While OSX makes it possible to use [[https://brew.sh/][Homebrew]] or [[https://www.erlang-solutions.com/resources/download.html][Erlang Solutions Ltd. packages]] to install pre-built versions of Erlang/OTP, you should only do so if you're trying things out the first time around. If you're planning on doing actual development for the longer haul, you'll instead want to be able to handle multiple versions at once.

The most commonly supported tool for this is [[https://github.com/kerl/kerl][kerl]]. Kerl is a wrapper around downloading, compiling, and loading various Erlang/OTP versions on a single system, and will abstract away most annoying operations.

You can install Kerl from homebrew by calling =$ brew install kerl=, or by following the instructions in its [[https://github.com/kerl/kerl#downloading][README file]].

Before installing Erlang, we will need to install and update a few dependencies, the main ones being to make sure you have [[https://developer.apple.com/xcode/][XCode]] installed and to then install OpenSSL (since OSX has terribly outdated copies of SSL by default):

#+NAME: openssl_osx
#+BEGIN_SRC sh
$ brew install openssl
...
$ ls /usr/local/Cellar/openssl/
1.0.2q
#+END_SRC

Note the full path this gives you for the local openssl install, here being =/usr/local/Cellar/openssl/1.0.2q/=

You can set the following options in your environment:

#+NAME: kerlcfg_osx
#+BEGIN_SRC sh
SSL_PATH=/usr/local/Cellar/openssl/1.0.2q/
export KERL_BUILD_BACKEND="git"
export KERL_CONFIGURE_OPTIONS="--without-javac \
                               --with-ssl=${SSL_PATH}"
#+END_SRC

And ensure it's active (for example, call =source ~/.bashrc=). These options specify what is accepted or expected from the build tool. The one here disables Java bindings, and uses the new SSL install we've made. You can look at the [[https://github.com/erlang/otp/blob/master/HOWTO/INSTALL.md#configuring-1][Build Instructions]] for more configuration options.

If you want to add more content, such as =Wx= (which lets you use and build GUIs), the [[https://github.com/erlang/otp/blob/master/HOWTO/INSTALL.md#os-x-darwin][Build instructions for OSX]] contain further details to guide you.

From that point on, you can download and install your own Erlang/OTP versions:

#+NAME: kerl_osx
#+BEGIN_SRC sh
$ kerl update releases
...
# kerl build <release> <build name>
$ kerl build 21.3 21.3
...
# kerl install <build name> <target path>
$ kerl install 21.3 ~/bin/erls/21.3/
...
# make that version active
$ . ~/bin/erls/21.3/activate
# or alternatively
$ source ~/bin/erls/21.3/activate
#+END_SRC

Any installed version can then be activated on-demand. If you want to set a default version, you can put the activation command in your =.bashrc= configuration file (or any shell profile you might have).

**** Linux

Linux distributions pretty much all have package managers that let you install pre-built copies of Erlang, or you can still use [[https://www.erlang-solutions.com/resources/download.html][Erlang Solutions Ltd. packages]]. Much like with OSX though, you should only do so if you're trying things out the first time around. If you're planning on doing actual development for the longer haul, you'll instead want to be able to handle multiple versions at once.

The most commonly supported tool for this is [[https://github.com/kerl/kerl][kerl]]. Kerl is a wrapper around downloading, compiling, and loading various Erlang/OTP versions on a single system, and will abstract away most annoying operations.

You can install kerl by calling:

#+NAME: linux_kerl
#+BEGIN_SRC sh
$ curl -O https://raw.githubusercontent.com/kerl/kerl/master/kerl
$ chmod a+x kerl
#+END_SRC

And then moving kerl to your path. Kerl will automatically check and warn you about missing dependencies you might be needing when building libraries, so you can just go ahead and run the following commands, and listen to its directions as you go.

First, you can set options as follows in your environment:

#+NAME: kerlcfg_linux
#+BEGIN_SRC sh
export KERL_BUILD_BACKEND="git"
export KERL_CONFIGURE_OPTIONS="--without-javac"
#+END_SRC

And ensure it's active (for example, call =source ~/.bashrc=). These options specify what is accepted or expected from the build tool. The one here disables Java bindings, but they would be skipped automatically anyway. You can look at the [[https://github.com/erlang/otp/blob/master/HOWTO/INSTALL.md#configuring-1][Build Instructions]] for more configuration options.

If you want to add more content, such as =Wx= (which lets you use and build GUIs), the [[https://github.com/erlang/otp/blob/master/HOWTO/INSTALL.md#building-with-wxerlang][Build instructions for Wx]] contain further details to guide you.

From that point on, you can download and install your own Erlang/OTP versions:

#+NAME: kerl_linux
#+BEGIN_SRC sh
$ kerl update releases
...
# kerl build <release> <build name>
$ kerl build 21.3 21.3
...
# kerl install <build name> <target path>
$ kerl install 21.3 ~/bin/erls/21.3/
...
# make that version active
$ . ~/bin/erls/21.3/activate
# or alternatively
$ source ~/bin/erls/21.3/activate
#+END_SRC

Any installed version can then be activated on-demand. If you want to set a default version, you can put the activation command in your =.bashrc= configuration file (or any shell profile you might have).

**** FreeBSD

On FreeBSD, some patches are required to make things work as smoothly as on other platforms. The good news is that if you use either the BSD [[https://www.freebsd.org/doc/en/books/handbook/ports-using.html][ports]] or [[https://www.freebsd.org/doc/en/books/handbook/pkgng-intro.html][packages]], it will all work fine out of the box.

This is the easiest way forwards, but makes switching across versions a bit trickier since you don't get an Erlang version manager for free. However, BSD ports and packages do let you build any version supported at your liking.

For example you can call any of the following:

#+NAME: bsd_install
#+BEGIN_SRC sh
# pkg install erlang # default copy
# pkg install erlang-runtime20  # OTP-20.x
# ls /usr/ports/lang/erlang* # source install: pick the version directory
erlang/
...
erlang-runtime20/
erlang-runtime21/
erlang-wx/
# cd /usr/ports/lang/erlang-runtime21/
# make config-recursive     # configure all the deps
# make install
#+END_SRC

FreeBSD maintainers are generally good about ensuring things keep working fine on the main supported architectures, so if you're sticking to x86 and avoid ARM, you should have no major issues.

*** Installing Rebar3

Rebar3 is the standard build tool within the Erlang community. It essentially bundles all of the other tools shipping with Erlang along with a few open-source ones, and makes them all work under a unified project structure.

There are a few ways to install Rebar3: from a pre-built binary, or from source, and then a last variant for a faster-running local install. Do note that in all cases, you need Erlang to have been installed already.

**** Pre-Built Binaries

Pre-built binaries can be found at [[https://www.rebar3.org/][www.rebar3.org]]. There's a big "Download" button with the latest stable version, but if you like to live more dangerously, you can grab [[https://s3.amazonaws.com/rebar3-nightly/rebar3][the latest _nightly_ build]] as well.

It is common to create a directory =~/bin/= to place commands line utilities like =rebar3=, which is where you might want to put the version you just downloaded. Call =chmod +x rebar3= on it to make sure it can run, and add it to your path with =export PATH=~/bin/:$PATH= in your =~/.bashrc=, =~/.zshrc= or equivalent.

Windows users who want to use the code from PowerShell or cmd.exe (rather than a terminal emulator) must ensure that a =rebar3.cmd= file is added:

#+NAME: rebar.cmd
#+BEGIN_SRC sh
@echo off
setlocal
set rebarscript=%~f0
escript.exe "%rebarscript:.cmd=%" %*
#+END_SRC

**** Building From Source

First make sure that you have git installed, and checkout the repository to build it:

#+NAME: rebar_bootstrap
#+BEGIN_SRC sh
$ git clone https://github.com/erlang/rebar3.git
$ cd rebar3
$ ./bootstrap
#+END_SRC

This will create a =rebar3= script file (along with a =rebar3.cmd= file on Windows).

**** Local Install

The local install form will let you take any of the previously built rebar3 versions, and unpack them to a local directory from which the tool will be able to self-update at a later time:

#+NAME: rebar_local
#+BEGIN_SRC sh
$ ./rebar3 local install  # starting from a rebar3 not in PATH
===> Extracting rebar3 libs to ~/.cache/rebar3/lib...
===> Writing rebar3 run script ~/.cache/rebar3/bin/rebar3...
===> Add to $PATH for use: export PATH=$PATH:~/.cache/rebar3/bin
$ export PATH=$PATH:~/.cache/rebar3/bin
$ rebar3 local upgrade # this can be used to update to the latest stable copy
...
#+END_SRC

*** Configuring Editors

**** Visual Studio Code
**** Emacs
**** Vim

** OTP at a High Level

*** The Erlang Run-Time System

Erlang/OTP is different from most programming environments out there, even those that also use a virtual machine. You may have heard people comparing Erlang to an operating system and that is an apt comparison. It's not that Erlang provides low-level primitives and drivers that let you run without an operating system--you'll still need that. Rather, it is that Erlang has a strong opinion about how your applications should be structured, the level of isolation they should have, and a separation between what Erlang's VM can do, and what your softwafe can do.

The foundational block for everything is the Erlang virtual machine itself, called BEAM. BEAM is technically a single implementation of the Erlang virtual machine, as there could be others. For example, Erllvm is an implementation over LLVM (using some custom patches to make everything possible), and an older implementation in the 90s was called JAM. The Erlang VM is implemented in C, and contains a lot of fancy stuff: schedulers to run processes, garbage collection, memory allocators, a timer wheel for events, a bunch of smart switches to abstract over operating system features and provide unified interfaces (such as over time management, file-handling drivers, and so on), a few built-in functions that go faster than what Erlang can do on its own (BIFs) and an interface for functions implemented natively in other languages (NIFs) along with special schedulures for them. There's obviously a lot more, but you can think of all that stuff the way you would with the kernel in BSD or Linux: low level stuff that you need in order to build fancier stuff.

If all you have is the virtual machine with nothing else, you can't run Erlang code. You don't have a standard library, you don't have libraries to even load code. There's some odd bootstrapping going on that we don't need to understand. Just know that there's a limited set of pre-loaded Erlang modules that ship with the virtual machine, and those can be used to set up networking and file-handling stuff that allows to further load and run modules. If you're interested in knowing more though, please consult [[https://happi.github.io/theBeamBook/][The BEAM Book]] or [[http://beam-wisdoms.clau.se/en/latest/][BEAM Wisdoms]].

If you take the virtual machine and the pre-loaded stuff, along with all the little utilities that make code-loading possible, you have what is essentially called the _Erlang Run-Time System_ (ERTS). The Run-Time System, when starting, follows the values of a thing called a _boot script_ (which nobody writes by hand) that specifies what to start. Erlang, by default, provides boot scripts that load code described in the next section as part of its boot sequence.

With this basic stuff in place, we fall into Erlang's space, something akin to userspace if we want to keep the comparison operating systems.

*** Erlang/OTP

If what we have right now is equivalent to the kernel, we need the foundational blocks for the userspace components. In Erlang, this is essentially what OTP is about. OTP specifies how "components" that run on the virtual machine should be structured. From the first start, there is more than just "processes and messages", there's one way to structure your code.

#+attr_shortcode: info
#+attr_latex: :environment bclogo :options [logo=\bcinfo, couleurBarre=orange, noborder=true, couleur=white]{Information}
#+begin_alert
OTP stands for _Open Telecom Platform_, which is literally a meaningless name that was used to get the stuff open-sourced back in the old days of Erlang at Ericsson.
#+end_alert

This is done through the use of components named _OTP Applications_. Every Erlang install that you use ships with a few of them, because it would be way too much trouble not to. There are basically two variants of OTP applications: _Library Applications_, which are just collections of modules, and regular _OTP Applications_, which contain a collection of modules, but also specify a stateful process structure stored under a supervision tree. For the sake of clarity, we're going to use the following terminology for OTP Applications for this entire book:

- _Library Applications_: stateless collections of modules
- _Runnable Applications_: OTP applications that start stateful supervision tree structures with processes running in them
- _OTP Applications_: either _Library_ or _Runnable Applications_, interchangeably

By default, the two OTP applications everyone includes are called =stdlib=, which is a library application that contains the core standard library modules such as =list= or =maps=, and =kernel=, which is a runnable application and sets up the core structure for an Erlang system that relies on OTP applications to work.

The way things go is that the modules from all required OTP applications are loaded in memory. Then =kernel= is started. Kernel manages the lifecycle of the system from this point on. All other OTP applications and their configuration are handled through it, and so are unique features like distribution and hot code updates. If we go back to the operating system comparison, you can think of the =kernel= OTP application a bit like you could think of =systemd= for the Linux kernel (or =init= if you hate =systemd= or use a BSD -- Windows users can think of it as the service that runs other services)

In fact, kernel and stdlib are the only two applications you need for a basic working Erlang shell. When you type in =erl= (or start =werl= on Windows), this boots up the VM, along with kernel, with =stdlib= pre-loaded. Everything else is optional and can be loaded at a later time.

The standard Erlang distribution contains applications such as:

- kernel
- stdlib
- crypto (cryptographic primitives)
- ssl (TLS termination library)
- inets (network services such as FTP or HTTP clients)
- ct (Common Test framework)
- wx (graphic toolkit)
- observer (a control panel to manage your Erlang node, building on =wx=)
- compiler (the Erlang compiler to build your own project)
- and so on

All of these are put together into what is called an Erlang _release_. A release is a collection of OTP applications, possibly bundled together with a full virtual machine. As such, when you download and install Erlang, you just get a release whose name is something like _Erlang/OTP-21.3.2_. You're free to build your own releases, which will take some of the OTP applications in the standard distribution, and then bundle them with some of your own apps.

So if we to write an app named =proxy= that relies on =ssh= and =ssl= (which themselves depend on =public_key=, =crypto=, =stdlib=, and =kernel=), we make a release with all of these components in it:

- ERTS
- kernel
- stdlib
- crypto
- public\_key
- ssl
- ssh
- proxy

A visual representation of this can be seen in Figure [[fig:proxy_release]].

#+CAPTION: Visual representation of building the =proxy= release
#+NAME:   fig:proxy_release
[[./static/img/proxy_release_draft.png]]

Essentially, building an Erlang system is re-bundling the VM, along with some standard applications provided with the default distribution, together with your own apps and libraries.

*** Living in Erlang/OTP

Standard tools developed and used by the community such as rebar3 basically operate on the idea that what you write and publish are OTP applications, and contains all the functionality required to deal with them. That's a big shift from a lot of programming languages that only ask of you to have a function named =main()= somewhere in one of your files. This is why the programming language is often called =Erlang/OTP= rather than just 'Erlang': it's not just a programming language, it's a general development framework that mandates some basic structure for everything you do.

And everyone follows it, whether they are writing embedded software, blockchain systems, or distributed databases. It's OTP or nothing. Whereas other languages usually mandate nothing specific to get started, but then add some requirements later on (such as when integrating with a package manager), Erlang--and its entire community--expects you to just write OTP applications, which the rest of the tools can handle.

So the key to getting started fast in Erlang is to know the framework, which is often kept as more advanced material. Here we're going to do things upside down and start from a fully functional release, and then dig down into its structure. The next chapters will be dedicated to understanding how to work within these requirements.


** OTP Applications

Since every component to be shipped in an Erlang/OTP release needs to be an OTP Application, it will do you a great good to understand what they are and how they work. In this chapter, we'll go over the basic structure of an OTP application, and what that means for your project.

*** Project Structure

We'll start by using the rebar3 templates, since they will allow us to create brand new projects that properly respect the directory structures expected by Erlang/OTP. Let's see which templates are available:

#+NAME: rebar3_new
#+BEGIN_SRC sh
$ rebar3 new
app (built-in): Complete OTP Application structure.
cmake (built-in): Standalone Makefile for building C/C++ in c_src
escript (built-in): Complete escriptized application structure
lib (built-in): Complete OTP Library application (no processes) structure
plugin (built-in): Rebar3 plugin project structure
release (built-in): OTP Release structure for executable programs
umbrella (built-in): OTP structure for executable programs
                     (alias of 'release' template)
#+END_SRC

Here's a table showing when they might be used:

| Type of Project                    | Template to use | Comments                                                            |
|------------------------------------+-----------------+---------------------------------------------------------------------|
| script or command line tool        | escript         | Requires Erlang to be installed by the user                         |
| a library (collection of modules)  | lib             | Can be used as a dependency                                         |
| a library (stateful processes)     | app             | Can be used as a dependency                                         |
| full executable program            | umbrella or app | Can be turned into a full release, the recommended deploy mechanism |
| a collection of multiple libraries | umbrella        | Cannot be used as a git dependency but each individual app could be published to hex |
| rebar3 extension                   | plugin          |                                                                     |
| compiling C code                   | cmake           | Also see the "pc" plugin for a portable way to compile C/C++        |

You can see the details of a given template by calling =rebar3 new help <template>=. See for example:

#+NAME: rebar3_new_lib
#+BEGIN_SRC sh
$ rebar3 new help lib
lib:
  built-in template
  Description: Complete OTP Library application (no processes) structure
  Variables:
    name="mylib" (Name of the OTP library application)
    desc="An OTP library" (Short description of the app)
    date="2019-03-15"
    datetime="2019-03-15T19:52:31+00:00"
    author_name="Fred Hebert"
    author_email="mononcqc@ferd.ca"
    copyright_year="2019"
    apps_dir="apps" (Directory where applications will be created if needed)
#+END_SRC

The values can be modified as desired on the command line, but those are the default variables. Let's see what we get by writing our own:

#+NAME: rebar3_new_mylib
#+BEGIN_SRC sh
$ rebar3 new lib mylib desc="Checking out OTP libs"
===> Writing mylib/src/mylib.erl
===> Writing mylib/src/mylib.app.src
===> Writing mylib/rebar.config
===> Writing mylib/.gitignore
===> Writing mylib/LICENSE
===> Writing mylib/README.md
#+END_SRC

Go to the =mylib= directory, and call =rebar3 compile= right away:

#+NAME: rebar3_mylib_compile
#+BEGIN_SRC sh
$ rebar3 compile
===> Verifying dependencies...
===> Compiling mylib
#+END_SRC

If you look at your directory structure, you should now have something like this in your project:


#+NAME: lib_structure
#+BEGIN_SRC sh
mylib/
├─ _build/
│  └─ default/
│     └─ lib/
│        └─ mylib/
│           ├─ ebin/
│           │  ├─ mylib.app
│           │  └─ mylib.beam
│           ├─ include/
│           ├─ priv/
│           └─ src/
│              └─ ...
├─ .gitignore
├─ LICENSE
├─ README.md
├─ rebar.config
├─ rebar.lock
└─ src/
   ├─ mylib.app.src
   └─ mylib.erl
#+END_SRC

The =_build/= directory is the build tool's playground, where it can stash all the artifacts it needs. You should never have to touch what is in there by hand. This directory is nonetheless interesting because it shows how rebar3 structures things.

Everything in =_build/= is split by [[https://www.rebar3.org/docs/profiles][profile]], which lets rebar3 build things differently (with different sets of dependencies and compiler options) whether they are built in the =default=, =test=, or =prod= profile—in fact, you can define as many profiles as you want, and compose them together. The rebar3 documentation explains how this works.

Within each profile, the =lib/= directory contains all the OTP applications that your project may use, outside of the standard distribution's libraries. You can see our =mylib= library replicated right there, but its directory structure is a bit different from what's directly at the project root:

- compiled =.erl= files are moved to the =ebin/= directory and now have the =.beam= extension
- there is a =mylib.app= file created, whereas the source application had =mylib.app.src=
- two symlinks have been added to =include/= and =priv/=. These will refer to matching directories at the root of the project, if they exist. The =include/= directory is meant for [[http://erlang.org/doc/reference_manual/macros.html#file-inclusion][header files]] (=.hrl=), and the =priv/= directory for any file that must be copied over and made available in production
- All other files at the root of the project have been discarded

If we had any dependencies (see [[Dependencies][the Dependencies chapter]]), they would also be placed in the =_build/<profile>/lib/= directory.

In general, you will want to ignore the =_build/= directory entirely and avoid tracking it in your source control: if you look at the =.gitignore= file, you will see that it automatically ignores =_build/= for you.

Rebar3 chooses a license for you by default (because you should always choose a license if you plan on doing open soruce work), going for the [[https://en.wikipedia.org/wiki/Apache_License#Version_2.0][Apache 2.0]] license that Erlang ships with. Feel free to replace it as required. Rebar3 also sets up a =README= file that you might want to fix up and update with all the relevant contents. Don't be a jerk, write documentation!

Then we get to two interesting files, =rebar.config= and =rebar.lock=. The lock file is used by rebar3 to track which versions of any dependencies you were using, and should be checked into source control. The [[Dependencies][Dependencies chapter]] contains more details.

The =rebar.config= file is a complete declarative configuration file that exposes options for all the Erlang tools that rebar3 integrates with. [[https://www.rebar3.org/docs/configuration][The official documentation]] explains all the values possible, but by default it is quite empty. In fact, if you only want default values with no dependencies, you can just delete the file. As long as your project is structured like an OTP application, rebar3 will figure out what needs to be done.

Let's see what the standards are for that to happen.

*** What Makes a Lib an App

You've possibly guessed it, but the directory structure is one of the basic requirements of a framework like OTP. As long as your library has an =ebin/= directory once compiled with an =<appname>.app= file in it, the Erlang runtime system will be able to load your modules and run your code.

This basic requirement guides the project structure of the entire Erlang ecosystem. Let's look at what a built =.app= file looks like:

#+NAME: mylib.app
#+BEGIN_SRC erlang
$ cat _build/default/lib/mylib/ebin/mylib.app
{application, mylib, [
  {description, "Checking out OTP libs"},
  {vsn, "0.1.0"},     % version number (string)
  {registered, []},   % name of registered processes, if any
  {applications, [    % List of OTP application names on which
    kernel, stdlib    % yours depends at run-time. kernel and
  ]},                 % stdlib are ALWAYS needed
  {env, []},          % default configuration values ({Key, Val} pairs)
  {modules, [mylib]}, % list of all the modules in the application
  %% content below is optional, and for package publication only
  {licenses, ["Apache 2.0"]},
  {links, []}         % relevant URLs
]}.
#+END_SRC

This is essentially a metadata file that describes everything about the application. We've taken the time to annotate it for you, so check it out. A lot of the content in there is annoying to write by hand so if you look at the source file (=src/mylib.app.src=), you'll see that the fields are mostly pre-populated. You may also notice that =modules= is empty. That's on purpose: rebar3 will populate the list for you.

By far, the most critical field to keep up to date in there is the =applications= tuple. It lets Erlang libraries know the order in which OTP applications must be started to work, and also allows build tools to build a dependency graph between all available OTP applications to know which to keep and which to remove from the distribution when building a release.

A more subtle thing to notice is that even if what we have here is a _library_, and it therefore has no processes to run, we still have the ability to define some configuration values (see the [[Configuration][Configuration Chapter]]), and dependencies must be respected. It is possible, for example, that our library is stateless, but uses a stateful HTTP client: the Erlang VM will then need to know when your code may or may not be safe to call.

For now, let's focus on what exactly is the difference between a stateless and a stateful application.

*** What Makes an App an App

To make a stateful application, we're going to use the "app" template in rebar3, and see what are the differences with a stateless application.

So let's grab your command line tool and run the following:

#+NAME: rebar3_new_myapp
#+BEGIN_SRC sh
$ rebar3 new app myapp
===> Writing myapp/src/myapp_app.erl
===> Writing myapp/src/myapp_sup.erl
===> Writing myapp/src/myapp.app.src
===> Writing myapp/rebar.config
===> Writing myapp/.gitignore
===> Writing myapp/LICENSE
===> Writing myapp/README.md
$ cd myapp
#+END_SRC

If you're careful, you'll see that we now have two new modules instead of =<appname>.erl=: we have =<appname>_app.erl= and =<appname>_sup.erl=. We'll study them real soon, but first, let's focus on the top-level metadata file for the application, the =myapp.app.src= file:

#+NAME: myapp.app.src
#+BEGIN_SRC erlang
$ cat src/myapp.app.src
{application, myapp,
 [{description, "An OTP application"},
  {vsn, "0.1.0"},
  {registered, []},
  {mod, {myapp_app, []}},               % this is new!
  {applications, [kernel, stdlib]},
  {env,[]},
  {modules, []},

  {licenses, ["Apache 2.0"]},
  {links, []}
 ]}.
#+END_SRC

The only new line here is the ={mod, {<appname>_app, []}}= tuple. This tuple specifies a special module that can be called (=<appname>_app=) with some specific arguments (=[]=). When called, it is expected that this module will return the _process identifier_ (the _pid_) of a [[Supervision Trees][supervision tree]].

If you go visit the =myapp_app= module, you will see what these callbacks are:

#+NAME: myapp_app.erl
#+BEGIN_SRC erlang
%%%-------------------------------------------------------------------
%% @doc myapp public API
%% @end
%%%-------------------------------------------------------------------

-module(myapp_app).
-behaviour(application).
%% Application callbacks
-export([start/2, stop/1]).

%%====================================================================
%% API
%%====================================================================

start(_StartType, _StartArgs) ->
    myapp_sup:start_link().

stop(_State) ->
    ok.
#+END_SRC

The =start/2= callback is called when the application is booted by the Erlang runtime system, at which point all of its dependencies—as defined in the =applications= tuple in the .app file—have already been started. This is where you can do one-time bits of initialization. In the template application, the only thing done is starting the root supervisor for the application.

The =stop/1= callback is called _after_ the whole supervision tree has been taken down once someone, somewhere, has decided to shut down the OTP application.

But all in all, this little additional =mod= line in the app file and the presence of a supervision structure are what differentiates a runnable application from a library application.

You now understand most of the weird stuff about Erlang/OTP's project structure and everything that has to do with these mysterious "OTP Applications". Starting with next chapter, we'll start digging a bit in supervision trees, so that you know how to set things up in a stateful runnable application.

ALSO

** Supervision Trees
*** Basics
*** Structuring Supervision Trees
*** Further resources
** Dependencies
** Projects with Multiple Applications
** Rebar3 Shell
** Configuration
** Documentation
** Testing
*** Common Test
*** Coverage
*** Dialyzer
*** XRef
*** Continuous Integration
** Things Hard to Get Right
*** Handling Unicode
*** Handling Time
*** SSL Configurations
* Production
:PROPERTIES:
:EXPORT_FILE_NAME: production
:END:
** Releases
*** Runtime Configuration
** Deployment
*** Release building
*** Docker Containers
*** Kubernetes
**** Deployment
**** Service
**** StatefulSet
**** Resources
***** CPUs
****** Active Schedulers
** Operations
*** Remote access
*** Metrics
**** VM
**** Libraries
**** Custom
*** Logging
*** Distributed tracing
* Team Building
:PROPERTIES:
:EXPORT_FILE_NAME: team_building
:END:
** Who to Put on The Team
*** Building Around an Expert
*** Building Without an Expert
*** To Remote or Not To Remote
** Repository Structures
** Processes
*** Code Reviews
*** Common Architecture Decisions
*** Prototype and Throw Away
*** Internal Training
** How To Hire
*** It Takes One to Know One
*** It is Easier to Train than Hire


NOTE:

things that have been badly covered or not covered

- basic data types
- comment syntax
- modules syntax
- basic Erlang shell
- include files with -include and -include_lib
- processes and process names
- links, supervisors, gen_servers
